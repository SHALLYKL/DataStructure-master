## 排序
### 内部排序
#### 插入排序
##### 直接插入排序
> 基本操作：将一个记录插入到已排好序的有序表中，从而得到一个新的有序表
##### 其它插入排序
###### 折半插入排序
> 基本操作：在一个有序表中进行查找和插入，查找使用折半查找来实现
> * <font color=#3F9AD6>折半插入排序所需附加存储空间和直接插入排序相同，从时间少比较，折半插入排序仅减少了关键字间的比较次数，而记录的移动次数不变。因此，折半插入排序的时间复杂度仍为*O(n²)* </font>

###### 2-路插入排序
> * 基本操作：在折半插入排序的基础上再改进之，其目的是减少排序过程中移动记录的次数，但为此需要n个记录的辅助空间
> * 具体做法：

###### 表插入排序

##### 希尔排序
#### 快速排序
#### 选择排序
##### 简单选择排序
##### 树形选择排序
##### 堆排序
#### 归并排序
#### 基数排序
##### 多关键字排序
##### 链式基数排序
#### 各种内部排序方法的比较讨论
<style>
table th:first-of-type {
	width: 100px;
}
table th:nth-of-type(2) {
	width: 100px;
}
table th:nth-of-type(3) {
	width: 100px;
}
table th:nth-of-type(4) {
	width: 100px;
}
table th:nth-of-type(5) {
	width: 100px;
}
table th:nth-of-type(6) {
	width: 100px;
}
</style>
| 排序方法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 | 适用场景 |  |
| --- | --- | --- | --- | --- | --- | --- |
| 直接插入排序 | O(n²) | 1 | 简洁易实现 | 时间复杂度高 | n值很小时 |  |
| 折半插入排序 | O(n²) | 1 | 简洁易实现 | 时间复杂度高 | n值很小时 |  |
|  |  |  |  |  |  |  |
### 外部排序